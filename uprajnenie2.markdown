### Упражнение 2 - Заиграване с данните

Вече имаме някакви данни в базата. Време е да се научим как да получаваме интересна информация от данните. Примерно по колко човека познаваме от дадена категория. Това може да се постигне по два начина:

Вариант 1: Групиране и агрегация;

    SELECT category, count(*) AS cnt 
    FROM chovek 
    GROUP BY category;

    category                     cnt       
    ---------------------------  ----------
    Приказен герой               2         
    Роднина                      1         

Заявката се "чете" по следния начин:

> Избери категория и броя редове за всяка категория от таблица **chovek** като групираш данните по категория.

SQL е много четим език, особено ако подбираме правилно имената на таблиците и колоните.

Интересното в резултата е че познаваме двама приказни герои и един роднина т.е. имаме социални проблеми и нужда от специализирана помощ.

Вариант 2: Вложени заявки (вложени селекти);

В този случай използването на вложени заявки е погрешно и ще забави излишно заявката но за пълнота на изложението ще го покажа тук:

    SELECT 
      c1.category, 
      (SELECT count(*) FROM chovek c2 WHERE c1.category = c2.category) AS cnt 
    FROM chovek c1 
    GROUP BY c1.category;

    category                     cnt       
    ---------------------------  ----------
    Приказен герой               2         
    Роднина                      1         

Доста по дълго и неприятно но все пак прочита е:

> Избери категория и за всяка категория преброй записите в таблицата за които имената на категориите са еднакви.

**c1** и **c2** се наричат псевдоними на таблиците (alias) а cnt се нарича псевдоним на колона (отново alias);

Резултатът от двете заявки е един и същ но е различен начинът по който те работят. Първата се изпълнява на един пас докато втората изпълнява външната заявка и за всеки резултатен ред от нея се изпълнява вътрешната заявка. Това е излишно в този случай и заявката освен по-дълга е и по-неефективна. Все пак има случаи в които вложените заявки ще ви бъдат от голяма полза.


### Декомпозиция и нормализация

Нашата малка табличка е малка приятна и лесна за употреба. Но дали е достатъчна. Преди десет години повечето хора имаха най-много един телефонен номер. Днес вече не е така, Повечето ни контакти са с по няколко номера а и все по рядко използват телефонът за разговори. 

Трябва да намерим начин да отразим реалността в нашето тефтерче. Интуитивният подход е да добавим още колони в таблицата. Можем да сложим примерно 3 колони за телефонни номера, 2 колони за e-mail адреси, една за IM комуникатор ... и всичко ще е идеално, докато не се запознаем с някой с 4 телефона или 3 e-mail адреса.

Първият проблем е че ще трябва често да променяме таблицата. Това освен неудобно може да бъде бавно или да "счупи" евентуален софтуер, който използва нашата база.
Вторият проблем са празните полета. В общия случай приятелите ни може да имат по един телефон но ние все пак ще заделяне по три полета за телефон за всеки човек. 

Ще използваме друг подход. Ще декомпозираме нашите данни за да направим базата по-гъвкава и разширяема.

Декомпозиция означава да вземем нашата композиция (в случая таблицата chovek) и да я раздробим на изграждащите я части. 
Частите в нашия случай са колоните:

* **id** се използва за указател на реда;
* **name** - името на човека което е кажи-речи уникално за всеки;
* **address** - адресът е като името и е уникален за всеки в общия случай. Ще извадим града от адреса, това ще ни позволи да изготвяме лесно няколко интересни справки;
* **phone** - телефонът също е уникален но в случая ще го заменим със средство за комуникация и ще го изведем в отделна таблица;
* **category** - категорията ще заменим с TAG-ове; Така ще разрешим проблемът със колега, който/която в същото време ни е приятел т.е. проблемът с хората които попадат в повече от една категория;



