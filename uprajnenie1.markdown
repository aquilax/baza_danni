### Упражнение 1 - Електронното тефтерче

Целта на първото упражнение е да създадем електронно тефтерче. Преди появата мобилните телефони, всички си записвахме телефоните а и адресите на познати и приятели в тефтерчета които често бяха азбучно разграфени. Целта ни е да създадем SQL версия на такова тефтерче, в което да добавяме информация за нашите приятели и познати. 

Да определим първо какви данни ще записваме за всеки човек:

* Име - за да знаем за кой става въпрос;
* Адрес - адресът на който живее;
* Телефонен номер;
* Категория - дали човекът е познат приятел роднина и.т.н.


Излежда че можем да поберем всичко в следната таблица:

    CREATE TABLE chovek (
      name varchar(10),
      address varchar(30),
      phone varchar(15),
      category varchar(15)
    );

Създаваме таблицата и можем да добавим няклко човека в нея. Можем да не указваме колоните на таблицата за INSERT ако спазваме последователността на колоните и укажем стойности за всяка колона.

    INSERT INTO chovek VALUES ("Иван", "София, Красно село", "02 123 123", "Приятел");
    INSERT INTO chovek VALUES ("Петкан", "Остров тимбукту, под палма 3", "", "Приказен герой");

Петкан няма телефон затова подаваме празен стринг "".

    INSERT INTO chovek VALUES ("Пипилота Виктуалия Транспаранта Ментолка Ефраимова - Дългото чорапче", "Вила вилекула", NULL, "Приказен герой");

Пипи дългото чорапче е интересен случай. Първо името и е много дълго цели 69 символа при 10 указани в схемата на таблицата. Някой СУБД, като SQLite или MySQL ще позволят да въведем записа, независимо че надхвърля ограничението от 10 символа, докато други като PostgreSQL ще откажат. Правилиният подход в случая е да променим типа на полето за име и да увеличим размерът му.

    ALTER TABLE chovek
    ALTER COLUMN name TYPE varchar(100);

Синтаксисът на ALTER се различава в зависимост от СУБД.

Второто интересно нещо в записа на Пипи е ключовата дума NULL. NULL се използва вместо нищо. То не е равно на нула, NULL е равно на нищо така че ако искаме да оставим някое поле празно, можем да използваме NULL като стойност (освен ако в дефиницията на полето не е указано изрично че то не може да е NULL).

Получаваме следната таблица:

<table>
<TR><TH>name</TH>
<TH>address</TH>
<TH>phone</TH>
<TH>category</TH>
</TR>
<TR><TD>Иван</TD>
<TD>София, Красно село</TD>
<TD>02 123 123</TD>
<TD>Приятел</TD>
</TR>
<TR><TD>Петкан</TD>
<TD>Остров тимбукту, под палма 3</TD>
<TD></TD>
<TD>Приказен герой</TD>
</TR>
<TR><TD>Пипилота Виктуалия Транспаранта Ментолка Ефраимова - Дългото чорапче</TD>
<TD>Вила вилекула</TD>
<TD></TD>
<TD>Приказен герой</TD>
</TR>
</table>

Ако искаме да видим кой е телефонът на Иван можем да използваме следната заявка:

    SELECT phone FROM chovek WHERE name = "Иван";

която генерира подобен резултат:

    phone     
    ----------
    02 123 123

За списък с адресите на всички хора с име започващо с буквата П, можем да използваме:

    SELECT address FROM chovek WHERE name LIKE "П%";

и резултатът:

    address                                           
    --------------------------------------------------
    Остров тимбукту, под палма 3
    Вила вилекула

Да добавим още един Иван. Този път роднина от Пловдив:

    INSERT INTO chovek VALUES ("Иван", "Пловдив, Голямо тепе", "032 32 32 32", "Роднина");

Вече имаме двама човека с името "Иван" в таблицата, ако решим да обновим единия, няма да можем да използваме само името като ключ. Примерно:

    UPDATE chovek SET address = "Пловдив, Средно тепе" WHERE name="Иван" AND category="Роднина";

Това изброяване често е дълго и досадно а в някой случаи и то не помага за избора на конкретен елемент. Примерно дядо и внук с еднакви имена живеещи на един и същ адрес. Затова златното правило е винаги да имаме първичен ключ в таблицата. Случаите които първичният ключ пречи са много малко и са по-скоро изключение.

Да започнем отначало с таблицата. Първо трябва да се отървем от старата таблица:

    DROP TABLE chovek

След това добавяме първичен ключ в схемата. По традиция името първичния ключ е id или комбинация от името на таблицата плюс _id.

    CREATE TABLE chovek (
      id integer NOT NULL AUTO_INCREMENT,
      name varchar(100),
      address varchar(30),
      phone varchar(15),
      category varchar(15)
    );

Това е синтаксисът за MySQL. В PostgreSQL можете да използвате типа serial, който автоматично създава генератор а в SQLite формата е:

    id INTEGER PRIMARY KEY AUTOINCREMENT

Накрая добавяме отново данните:

    INSERT INTO chovek VALUES (NULL, "Иван", "София, Красно село", "02 123 123", "Приятел");
    INSERT INTO chovek VALUES (NULL, "Петкан", "Остров тимбукту, под палма 3", "", "Приказен герой");
    INSERT INTO chovek VALUES (NULL, "Пипилота Виктуалия Транспаранта Ментолка Ефраимова - Дългото чорапче", "Вила вилекула", NULL, "Приказен герой");
    INSERT INTO chovek VALUES (NULL, "Иван", "Пловдив, Голямо тепе", "032 32 32 32", "Роднина");
    UPDATE chovek SET address = "Пловдив, Средно тепе" WHERE name="Иван" AND category="Роднина";

и получаваме следната таблица:

    SELECT * FROM chovek;

<table>
<TR><TH>id</TH>
<TH>name</TH>
<TH>address</TH>
<TH>phone</TH>
<TH>category</TH>
</TR>
<TR><TD>1</TD>
<TD>Иван</TD>
<TD>София, Красно село</TD>
<TD>02 123 123</TD>
<TD>Приятел</TD>
</TR>
<TR><TD>2</TD>
<TD>Петкан</TD>
<TD>Остров тимбукту, под палма 3</TD>
<TD></TD>
<TD>Приказен герой</TD>
</TR>
<TR><TD>3</TD>
<TD>Пипилота Виктуалия Транспаранта Ментолка Ефраимова - Дългото чорапче</TD>
<TD>Вила вилекула</TD>
<TD></TD>
<TD>Приказен герой</TD>
</TR>
<TR><TD>4</TD>
<TD>Иван</TD>
<TD>Пловдив, Средно тепе</TD>
<TD>032 32 32 32</TD>
<TD>Роднина</TD>
</TR>
</table>

Сега можем да изтрием много лесно Иван от София, който вече не ни е приятел:

    DELETE FROM chovek WHERE id = 1;

Звучи малко грубо но това е само пример.
