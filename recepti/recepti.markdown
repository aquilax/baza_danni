## Приоритизиране на резултатите от UNION

Има случаи в които трябва да използваме UNION за да обединим резултатите от няколко заявки. Подобен пример е търсене на текст в няколко таблици примерно:

~~~ {.sql}
SELECT id, name FROM table1 WHERE name LIKE "%search%"
UNION
SELECT id, name FROM table2 WHERE name LIKE "%search%"
UNION
SELECT id, name FROM table3 WHERE name LIKE "%search%"
~~~

В общия случай данните, които ще получим ще са подредени в реда, в който сме подредили заявките но това не е гарантирано. Ако искаме да върнем резултатите в ред според таблицата, от която са, можем да използваме следния трик:

~~~ {.sql}
SELECT id, name FROM (
  SELECT id, name, 1 AS ordr FROM table1 WHERE name LIKE "%search%"
  UNION
  SELECT id, name, 3 AS ordr FROM table2 WHERE name LIKE "%search%"
  UNION
  SELECT id, name, 2 AS ordr FROM table3 WHERE name LIKE "%search%"
) AS t 
ORDER BY ordr;
~~~

Добавяме една "фалшива" колона в резултата, която използваме във външната заявка за сортиране. В случая резултатите ще се подредят в реда първа, трета, втора таблица.

## Частично възстановяване на данни от архив

Понякога се случва да напишем заявка от рода на:

~~~ {.sql}
UPDATE posts 
SET user_id=1;
~~~

докато всъщност искаме да кажем:

~~~ {.sql}
UPDATE posts 
SET user_id=1
WHERE id = 155633;
~~~

В такива случаи се налага да възстановим данните от архив но докато се ровим из архивите на базата в таблицата продължават да се трупат записи, които са верни. Целта ни е да възстановим колоната **user_id** в таблица **user** от архивно копие.

Първо възстановяваме таблицата от архива с ново име, примерно **user_bak** и наливаме архивните данни.
Остава само да обновим колоната със следната заявка:

~~~ {.sql}
UPDATE 
user u, user_bak ub
SET u.user_id = ub.user_id
WHERE u.id = ub.id
~~~

Накрая изтриваме архивната таблица:

~~~ {.sql}
DROP TABLE user_bak;
~~~

и отиваме да си премерим пулса.
