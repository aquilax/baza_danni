## Упражнение 2 - Заиграване с данните

Вече имаме някакви данни в базата. Време е да се научим как да получаваме интересна информация от данните. Примерно по колко човека познаваме от дадена категория. Това може да се постигне по два начина:

Вариант 1: Групиране и агрегация;

~~~ {.sql}
SELECT category, count(*) AS cnt 
FROM chovek 
GROUP BY category;
~~~

    category                     cnt       
    ---------------------------  ----------
    Приказен герой               2         
    Роднина                      1         

Заявката се "чете" по следния начин:

> Избери категория и броя редове за всяка категория от таблица **chovek** като групираш данните по категория.

SQL е много четим език, особено ако подбираме правилно имената на таблиците и колоните.

Интересното в резултата е че познаваме двама приказни герои и един роднина т.е. имаме социални проблеми и нужда от специализирана помощ.

Вариант 2: Вложени заявки (вложени селекти);

В този случай използването на вложени заявки е погрешно и ще забави излишно заявката но за пълнота на изложението ще го покажа тук:

~~~ {.sql}
SELECT 
  c1.category, 
  (SELECT count(*) FROM chovek c2 WHERE c1.category = c2.category) AS cnt 
FROM chovek c1 
GROUP BY c1.category;
~~~

    category                     cnt       
    ---------------------------  ----------
    Приказен герой               2         
    Роднина                      1         

Доста по дълго и неприятно но все пак прочита е:

> Избери категория и за всяка категория преброй записите в таблицата за които имената на категориите са еднакви.

**c1** и **c2** се наричат псевдоними на таблиците (alias) а cnt се нарича псевдоним на колона (отново alias);

Резултатът от двете заявки е един и същ но е различен начинът по който те работят. Първата се изпълнява на един пас докато втората изпълнява външната заявка и за всеки резултатен ред от нея се изпълнява вътрешната заявка. Това е излишно в този случай и заявката освен по-дълга е и по-неефективна. Все пак има случаи в които вложените заявки ще ви бъдат от голяма полза.

## Декомпозиция и нормализация

Нашата малка табличка е малка приятна и лесна за употреба. Но дали е достатъчна. Преди десет години повечето хора имаха най-много един телефонен номер. Днес вече не е така, Повечето ни контакти са с по няколко номера а и все по рядко използват телефонът за разговори. 

Трябва да намерим начин да отразим реалността в нашето тефтерче. Интуитивният подход е да добавим още колони в таблицата. Можем да сложим примерно 3 колони за телефонни номера, 2 колони за e-mail адреси, една за IM комуникатор ... и всичко ще е идеално, докато не се запознаем с някой с 4 телефона или 3 e-mail адреса.

Първият проблем е че ще трябва често да променяме таблицата. Това освен неудобно може да бъде бавно или да "счупи" евентуален софтуер, който използва нашата база.
Вторият проблем са празните полета. В общия случай приятелите ни може да имат по един телефон но ние все пак ще заделяне по три полета за телефон за всеки човек. 

Ще използваме друг подход. Ще декомпозираме нашите данни за да направим базата по-гъвкава и разширяема.

Декомпозиция означава да вземем нашата композиция (в случая таблицата chovek) и да я раздробим на изграждащите я части. 
Частите в нашия случай са колоните:

* **id** се използва за указател на реда;
* **name** - името на човека което е кажи-речи уникално за всеки;
* **address** - адресът е като името и е уникален за всеки в общия случай. Ще извадим града от адреса, това ще ни позволи да изготвяме лесно няколко интересни справки;
* **phone** - телефонът също е уникален но в случая ще го заменим със средство за комуникация и ще го изведем в отделна таблица;
* **category** - категорията ще заменим с TAG-ове; Така ще разрешим проблемът със колега, който/която в същото време ни е приятел т.е. проблемът с хората които попадат в повече от една категория;

Диаграма на светлото бъдеще:

    +----------+       +------+     +-----------------+
    | chovek   |       | city |     | contact         |
    |----------|       |------|     |-----------------|
    | id       |       | id   |     | id              |
    | city_id  |       | name |     | contact_type_id |
    | name     |       +------+     | chovek_id       |
    | address  |                    | val             |
    | created  |                    | created         |
    +----------+                    +-----------------+

    +------------+     +------+     +--------------+
    | chovek_tag |     | tag  |     | contact_type |
    |------------|     |------|     |--------------|
    | id         |     | id   |     | id           |
    | chovek_id  |     | name |     | name         |
    | tag_id     |     +------+     +--------------+
    +------------+


Изглежда чудовищно на фона на удобната ни таблица и донякъде е така. В случая заменяме удобство за гъвкавост. Следват малко разяснения за таблиците:

* **chovek** - тук сме запазили името и адреса на човека, тъй като са сравнително уникални за всеки. Добавена е колоната **city_id**, която ще е нашата връзка към градовете а също така и една колона **created**, в която ще си записваме кога сме добавили човека;
* **city** - таблица за населените места (въпреки че се казва city);
* **tag** - тук ще се помещават различните категории хора: познати, приятели, колеги, зомбита;
* **contact_type** - различните типове контакти, които ще записваме за хората: телефон, e-mail, jabber;
* **contact** - това ще е самият контакт. Има полета за връзка към типа контакт и към човека, поле за стойност и още едно за датата и часа в които сме добавили контакта;
* **chovek_tag** - това е свързочна таблица за "много към много връзка". Тя ще свързва хората с категориите;

Схемите за създаване на таблиците (в случая SQLite3) са:


~~~ {.sql}
CREATE TABLE chovek (
  id INTEGER PRIMARY KEY AUTO INCREMENT,
  city_id INTEGER NOT NULL,
  name VARCHAR(100),
  address VARCHAR(30),
  created TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE city (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name VARCHAR(30)
);

CREATE TABLE contact (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  contact_type_id INTEGER NOT NULL,
  chovek_id INTEGER NOT NULL,
  val VARCHAR(100),
  created TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE chovek_tag (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  chovek_id INTEGER NOT NULL,
  tag_id INTEGER NOT NULL
);

CREATE TABLE tag (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name VARCHAR(30)
);

CREATE TABLE contact_type(
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name VARCHAR(30)
);
~~~


И да налеем малко данни:

Два града: София и Пловдив

~~~ {.sql}
INSERT INTO city VALUES (NULL, "София");
INSERT INTO city VALUES (NULL, "Пловдив");
~~~

~~~ {.sql}
SELECT * FROM city;
~~~

<table>
<TR><TH>id</TH>
<TH>name</TH>
</TR>
<TR><TD>1</TD>
<TD>София</TD>
</TR>
<TR><TD>2</TD>
<TD>Пловдив</TD>
</TR>
</table>



